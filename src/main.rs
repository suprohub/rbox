use std::{
    collections::HashMap,
    error::Error,
    fs::{self, File},
    io::{self, Write},
    sync::Arc,
    time::{Duration, Instant, SystemTime, UNIX_EPOCH},
};

use base64::Engine;
use reqwest::Client;
use serde::Deserialize;
use serde_json::Value;
use tokio::sync::Mutex;

type AsyncError = Box<dyn std::error::Error + Sync + Send>;

#[derive(Deserialize)]
pub struct Sources {
    #[serde(rename = "max-ping")]
    max_ping: u16,
    repeats: u8,
    sources: Vec<Vec<String>>,
}

#[tokio::main]
async fn main() {
    simple_logger::init_with_level(log::Level::Info).unwrap();
    log::info!("Start creating best proxy list...");

    let sources: Sources = toml::from_str(&fs::read_to_string("sources.toml").unwrap()).unwrap();
    let map = Arc::new(Mutex::new(HashMap::new()));
    let client = Client::new();
    let mut tasks = Vec::new();

    for source in sources.sources {
        let map_clone = map.clone();
        tasks.push(tokio::spawn(check_sub(
            map_clone,
            client.clone(),
            source[0].clone(),
            source
                .get(1)
                .map(|val| val.parse().unwrap())
                .unwrap_or(sources.max_ping),
            source
                .get(2)
                .map(|val| val.parse().unwrap())
                .unwrap_or(sources.repeats),
        )));
    }

    for task in tasks {
        task.await.unwrap().unwrap();
    }

    let current_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    let mut sorted = Arc::try_unwrap(map)
        .unwrap()
        .into_inner()
        .into_iter()
        .collect::<Vec<(String, u16)>>();
    sorted.sort_by_key(|k| k.1);

    sorted.insert(0, (format!("ss://bm9uZTpjYWFjYmJhLWJhY2EtY2FiYS1kY2FiLWJjYmFhY2NhYmJjYQ==@127.0.0.1:1080#GENERATED BY RBOX ðŸ”„ LATEST-UPDATE ðŸ“… {current_time}"), 0));

    fs::remove_dir_all("result").unwrap();
    fs::create_dir("result").unwrap();

    let mut subs = File::create("result/best_subscribition_by_rbox.txt").unwrap();
    let mut pings = File::create("result/pings.txt").unwrap();
    for (sub, ping) in sorted {
        subs.write_all(sub.as_bytes()).unwrap();
        subs.write_all(b"\n").unwrap();
        pings.write_all(ping.to_string().as_bytes()).unwrap();
        pings.write_all(b"\n").unwrap();
    }

    log::info!("Best proxy list created! Stopping...");
}

async fn check_sub(
    map: Arc<Mutex<HashMap<String, u16>>>,
    client: Client,
    url: String,
    timeout: u16,
    repeats: u8,
) -> Result<(), AsyncError> {
    let subs = reqwest::get(&url).await?.text().await?;
    let len = subs.lines().count();
    let mut count = 0;
    log::info!(
        "Start pinging subscribition {} with repeats {} and len {}",
        url,
        repeats,
        len
    );

    if repeats > 1 {
        let mut result: HashMap<&str, Vec<u16>> = HashMap::new();

        count = 0;
        let mut tasks = Vec::new();
        for sub in subs.lines() {
            tasks.push((
                sub,
                tokio::spawn(ping_proto(client.clone(), sub.to_string(), timeout)),
            ));
        }

        log::info!("Tasks created in subscribition {} with repeat 1", url,);
        for (sub, task) in tasks {
            log::info!("proxy number {count}/{len} repeat 1");
            let mut vec = Vec::new();
            if let Ok(ping) = task.await? {
                vec.push(ping);
            }
            result.insert(sub, vec);
            count += 1;
        }

        for repeat in 2..repeats + 1 {
            count = 0;
            let mut tasks = Vec::new();
            for sub in subs.lines() {
                tasks.push((
                    sub,
                    tokio::spawn(ping_proto(client.clone(), sub.to_string(), timeout)),
                ));
            }

            log::info!(
                "Tasks created in subscribition {} with repeat {}",
                url,
                repeat
            );
            for (sub, task) in tasks {
                log::info!("proxy number {count}/{len} repeat {repeat}");
                if let Ok(ping) = task.await? {
                    result.get_mut(sub).unwrap().push(ping);
                    count += 1;
                }
            }
        }

        map.lock()
            .await
            .extend(result.into_iter().filter(|val| val.1.len() > 0).map(|val| {
                (
                    val.0.to_string(),
                    (val.1.iter().sum::<u16>() as f32 / val.1.len() as f32).round() as u16,
                )
            }));
    } else {
        let mut tasks = Vec::new();
        for sub in subs.lines() {
            tasks.push((
                sub,
                tokio::spawn(ping_proto(client.clone(), sub.to_string(), timeout)),
            ));
        }

        log::info!("Tasks created in subscribition {} with no repeats", url);
        for (sub, task) in tasks {
            log::info!("proxy number {count}/{len}");
            if let Ok(ping) = task.await? {
                map.lock().await.insert(sub.to_string(), ping);
            }
            count += 1;
        }
    }

    log::info!("Finished inging subscribition {}", url);

    Ok(())
}

async fn ping_proto(client: Client, url: String, timeout: u16) -> Result<u16, AsyncError> {
    let ping = match url {
        _ if url.starts_with("ss://")
            || url.starts_with("trojan://")
            || url.starts_with("vless://") =>
        {
            if let Some(ping) = url.split_once('@') {
                let mut ping = ping.1.split_once('#').unwrap_or((ping.1, "")).0;
                ping = ping.split_once('?').unwrap_or((ping, "")).0;
                ping.to_string()
            } else {
                let proto: HashMap<String, Value> = serde_json::from_str(&String::from_utf8(
                    base64::engine::general_purpose::STANDARD.decode(
                        url.replace("vmess://", "")
                            .replace("trojan://", "")
                            .replace("ss://", ""),
                    )?,
                )?)?;
                let addr = proto.get("add").unwrap().as_str().unwrap().to_string()
                    + ":"
                    + &proto
                        .get("port")
                        .unwrap()
                        .as_str()
                        .map(|str| str.to_string())
                        .unwrap_or_else(|| {
                            proto
                                .get("port")
                                .unwrap()
                                .as_u64()
                                .unwrap_or_else(|| {
                                    println!("proto {:?}", proto);
                                    0
                                })
                                .to_string()
                        });
                addr
            }
        }
        _ if url.starts_with("vmess://") => {
            let vmess: HashMap<String, Value> = serde_json::from_str(&String::from_utf8(
                base64::engine::general_purpose::STANDARD.decode(url.replace("vmess://", ""))?,
            )?)?;
            let addr = vmess.get("add").unwrap().as_str().unwrap().to_string()
                + ":"
                + &vmess
                    .get("port")
                    .unwrap()
                    .as_str()
                    .map(|str| str.to_string())
                    .unwrap_or_else(|| {
                        vmess
                            .get("port")
                            .unwrap()
                            .as_u64()
                            .unwrap_or_else(|| {
                                println!("vmess {:?}", vmess);
                                0
                            })
                            .to_string()
                    });
            addr
        }
        _ => {
            return Err(Box::new(io::Error::new(
                io::ErrorKind::AddrNotAvailable,
                "unknown proto",
            )));
        }
    };

    if !ping.starts_with("127.0.0.1") {
        let time = Instant::now();
        match client
            .get("http://".to_string() + &ping)
            .timeout(Duration::from_millis(timeout.into()))
            .send()
            .await
        {
            Ok(_) => Ok(time.elapsed().as_millis() as u16),
            Err(err) => {
                //println!("{:?}", err);
                if !err.is_timeout() {
                    Ok(time.elapsed().as_millis() as u16)
                } else if let Some(status) = err.status() {
                    if status.as_u16() > 400 {
                        Err(Box::new(err))
                    } else {
                        Ok(time.elapsed().as_millis() as u16) 
                    }
                } else {
                    Err(Box::new(err))
                }
            }
        }
    } else {
        Err(Box::new(io::Error::new(
            io::ErrorKind::AddrInUse,
            "bruh its local host bro",
        )))
    }
    /*TcpStream::connect_timeout(
        &ping.to_socket_addrs()?.collect::<Vec<SocketAddr>>()[0],
        Duration::from_millis(timeout.into()),
    )?;*/
}
